# -*- coding: utf-8 -*-
"""MapeamentoObras

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oHqfsGKtL39q291jTq_kwXw40K2NQbwQ

# Mapeamento de Colaborações em Obras da UFRN
https://github.com/lumathias/ProjetoAED/edit/main/README.md

Luisa de Moura Galvão Mathias 20220080650

Viviane Stephane Pinheiro Novo 20240001144

# Instalações e importações
"""

!pip install networkx pandas matplotlib nxviz

# Bibliotecas
import pandas as pd
import networkx as nx
import numpy as np
import io
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from collections import defaultdict
from nxviz import CircosPlot
from itertools import combinations

# Importação do computador
from google.colab import files
uploaded = files.upload()

# Carregando o arquivo CSV
df = pd.read_csv('obras.csv', sep=';')

print(df.head())

"""# Processamento"""

# CRIAÇÃO DO GRAFO (Nós e Arestas)

G = nx.Graph() # grafo não direcionado

# Adiciona Nós de Obras e Nós de Empresas ao grafo
obras_nodes = df['id_obra'].unique()
empresas_nodes = df['empresa'].unique()

G.add_nodes_from(obras_nodes, bipartite=0, type='Obra')
G.add_nodes_from(empresas_nodes, bipartite=1, type='Empresa')

# limpa e converte 'valor' p/ valor numericoantes de add atributos de nós e arestas
df['valor_numeric'] = df['valor'].astype(str).str.replace('R$', '', regex=False).str.replace('.', '', regex=False).str.replace(',', '.', regex=False).str.strip()
df['valor_numeric'] = pd.to_numeric(df['valor_numeric'], errors='coerce')


# adiciona arestas (Obra <--> Empresa)
for index, row in df.iterrows():
    id_obra = row['id_obra']
    empresa = row['empresa']
    valor_numeric = row['valor_numeric']
    status = row['status_obra']

    # add aresta com 'valor_numeric' como peso
    if pd.notna(valor_numeric): # só add aresta se valor não for NaN
        G.add_edge(id_obra, empresa, weight=valor_numeric, status_obra=status)

# adicionar atributos aos Nós
# status da obra --> nós de obra, e o valor total --> empresa
for node in G.nodes():
    if G.nodes[node]['type'] == 'Obra':
        # Add status e unidade responsável ao 'work node'
        obra_data = df[df['id_obra'] == node].iloc[0]
        G.nodes[node]['status'] = obra_data.get('status_obra', 'Unknown')
        G.nodes[node]['unidade'] = obra_data.get('unidade_responsavel')
        # Add o valor numerico como um atributo para os nós de Obra
        G.nodes[node]['valor_associado'] = obra_data.get('valor_numeric', 0)
    elif G.nodes[node]['type'] == 'Empresa':
        # Calcula o valor total de projetos da empresa somando os pesos
        total_valor = sum(data.get('weight', 0) for u, v, data in G.edges(node, data=True))
        G.nodes[node]['valor_associado'] = total_valor


print(f"\n Grafo criado com {G.number_of_nodes()} nós e {G.number_of_edges()} arestas.")

# CÁLCULO DE MÉTRICAS DA REDE

# Propriedades Básicas
print(f"\n----- Análise de Propriedades Básicas -----")
print(f"Número de Nós: {G.number_of_nodes()}")
print(f"Número de Arestas: {G.number_of_edges()}")
densidade = nx.density(G) # densidade da Rede
print(f"Densidade da Rede (conexão entre nós): {densidade:.4f}")

# grau dos Nós
degree_dict = dict(G.degree())
print(f"\n----- Análise de Grau dos Nós -----")
# filtra e mostra o grau das Empresas (quantas obras executaram)
for node, degree in degree_dict.items():
    if node in empresas_nodes:
        print(f"Empresa '{node}': Grau {degree}")

# assortatividade da rede
# Mede se nós de alto grau (Empresas grandes) tendem a se conectar com outros de alto grau
assortativity = nx.degree_assortativity_coefficient(G)
print(f"\nAssortatividade por Grau: {assortativity:.4f}")
# é esperado próximo de 0 para obra-empresa

# DISTRIBUIÇÃO DE PROBABILIDADE/HISTOGRAMA DOS GRAUS

degrees = [degree for node, degree in G.degree()]
plt.figure(figsize=(20, 8))
plt.hist(degrees, bins=range(min(degrees), max(degrees) + 2), align='left', color='skyblue', edgecolor='black')
plt.title('Histograma da Distribuição de Graus')
plt.xlabel('Grau do Nó (Número de Conexões)')
plt.ylabel('Frequência')
plt.xticks(range(min(degrees), max(degrees) + 1))
plt.grid(axis='y', alpha=0.5)
plt.show()

# VISUALIZAÇÃO DO GRAFO (NETWORKX/MATPLOTLIB)

plt.figure(figsize=(15, 15)) # Increased figure size for better visualization
pos = nx.spring_layout(G, k=0.5, seed=42) # Added seed for reproducible layout and adjusted k

# Configuração de Cores e Tamanhos
node_colors = []
node_sizes = []
labels = {}
edge_widths = []

for node in G.nodes():
    if G.nodes[node]['type'] == 'Empresa':
        node_colors.append('red')
        # Size of company nodes based on their degree (number of projects)
        node_sizes.append(G.degree(node) * 50) # Scaled for better visibility
        labels[node] = node
    else: # Obra
        # Cor da obra baseada no Status [3]
        status = G.nodes[node].get('status', 'Unknown') # Handle potential missing status
        if status == 'Atrasada':
            node_colors.append('orange')
        elif status == 'Em Andamento':
             node_colors.append('blue')
        else: # Concluída or Unknown
            node_colors.append('green')

        # Tamanho do nó da obra baseado no valor (ponderação)
        # Get the numeric value from the edge connected to the work node
        # Since it's a bipartite graph, each work node is connected to exactly one company node
        valor_numeric = 0
        for u, v, data in G.edges(node, data=True):
            valor_numeric = data.get('weight', 0)
            break # Assuming one edge per work node in this context

        node_sizes.append(valor_numeric / 5000) # Scaled for better visibility
        labels[node] = str(node) # Mostra o ID da obra

# Desenho dos Nós
nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=node_sizes, alpha=0.8)

# Desenho das Arestas (Ponderação visual: espessura da linha baseada no valor)
for u, v, data in G.edges(data=True):
    # Escala a largura da aresta (dividir por um fator grande)
    edge_widths.append(data.get('weight', 0) / 500000) # Scaled for better visibility

nx.draw_networkx_edges(G, pos, width=edge_widths, alpha=0.4, edge_color='gray')

# Desenho dos Rótulos
nx.draw_networkx_labels(G, pos, labels=labels, font_size=8) # Adjusted font size

plt.title('Grafo Bipartido: Obras vs. Empresas (Tamanho pelo Valor do Contrato)')
plt.axis('off')
plt.show()

# ----------------------------------------------------
# Interpretação da Visualização
# A empresa 'Construtora Alfa' (nó vermelho) é um hub de alto grau.
# A Obra 'Nova Biblioteca' (laranja, atrasada) tem o maior valor (maior tamanho).
# ----------------------------------------------------

def limpar_valor(valor_str):
    """Remove R$, espaços, pontos (milhares) e troca vírgula por ponto (decimal)."""
    if isinstance(valor_str, str):
        # 1. Remove R$ e espaços
        valor_str = valor_str.replace('R$', '').strip()
        # 2. Remove o ponto de milhares ('.')
        valor_str = valor_str.replace('.', '')
        # 3. Troca a vírgula decimal (',') pelo ponto ('.')
        valor_str = valor_str.replace(',', '.')
    try:
        return float(valor_str)
    except ValueError:
        return 0.0 # Retorna zero se a conversão falhar

# Aplica a limpeza
df['valor_float'] = df['valor'].apply(limpar_valor)

# Pré-limpeza da coluna empresa (remover espaços e aspas extras)
df['empresa'] = df['empresa'].str.strip().str.replace('"', '')

print("DataFrame Limpo (Primeiras Linhas e Valores):")
print(df[['id_obra', 'empresa', 'valor', 'valor_float', 'status_obra']].head())

# ----------------------------------------------------
# 2.1 CRIAÇÃO DO GRAFO E ATRIBUIÇÃO DE PARTIÇÕES
# ----------------------------------------------------
G = nx.Graph()

obras_nodes = df['id_obra'].unique()
empresas_nodes = df['empresa'].unique()

# Adiciona Nós de Obras e Empresas com seus atributos
for id_obra in obras_nodes:
    # Get the specific row for the current id_obra using boolean indexing and iloc[0]
    obra_row = df[df['id_obra'] == id_obra].iloc[0]
    G.add_node(id_obra,
               bipartite=0,
               type='Obra',
               status=obra_row['status_obra'],
               valor=obra_row['valor_float'],
               qtd_dias=obra_row['qtd_dias'])

for empresa in empresas_nodes:
    G.add_node(empresa,
               bipartite=1,
               type='Empresa')

# Adiciona Arestas Ponderadas
for index, row in df.iterrows():
    # Aresta ponderada pelo valor_float
    G.add_edge(row['id_obra'],
               row['empresa'],
               weight=row['valor_float'])

print(f"\nGrafo Bipartido criado com {G.number_of_nodes()} nós e {G.number_of_edges()} arestas.")

# Se houver poucos dados (como neste exemplo), pulamos a filtragem extrema para não esvaziar o grafo.
if G.number_of_nodes() > 10:

    # 3.1 Identificar Hubs (Exemplo: Top 5 empresas por grau)
    degree_empresas = {n: d for n, d in G.degree() if G.nodes[n]['bipartite'] == 1}
    top_empresas = sorted(degree_empresas, key=degree_empresas.get, reverse=True)[:5]

    # 3.2 Obras de Alto Risco/Valor
    risco_obras = [n for n in G.nodes() if G.nodes[n].get('status') in ['Atrasada', 'Paralisada']]

    # Obras mais caras (ex: acima da média ou do 90º percentil)
    todos_valores = [G.nodes[n]['valor'] for n in G.nodes() if G.nodes[n]['type'] == 'Obra']
    if todos_valores:
        valor_corte = np.percentile(todos_valores, 90)
        valor_obras = [n for n in G.nodes() if G.nodes[n].get('valor', 0) >= valor_corte and G.nodes[n]['type'] == 'Obra']
    else:
        valor_obras = []

    foco_nodes = set(top_empresas) | set(risco_obras) | set(valor_obras)
    G_foco = G.subgraph(foco_nodes).copy()
else:
    # Se o grafo for pequeno (como o exemplo fornecido), visualize o grafo completo
    G_foco = G
    print("Grafo pequeno, visualizando o conjunto completo de nós.")

# Separa as partições do subgrafo de foco
obras_foco = [n for n in G_foco.nodes() if G_foco.nodes[n]['bipartite'] == 0]
empresas_foco = [n for n in G_foco.nodes() if G_foco.nodes[n]['bipartite'] == 1]

# ----------------------------------------------------
# 4.1 VISUALIZAÇÃO ESTRUTURADA (LAYOUT BI-PARTIDO)
# ----------------------------------------------------

# Aplica o layout bi-partido (separa Obras e Empresas visualmente)
try:
    pos = nx.bipartite_layout(G_foco, obras_foco)
except ValueError:
    # Se uma das partições estiver vazia após a filtragem, use um layout padrão
    pos = nx.spring_layout(G_foco)


# Configuração de Cores e Tamanhos
node_colors = []
node_sizes = []
labels = {}

for node in G_foco.nodes():
    node_type = G_foco.nodes[node]['type']

    if node_type == 'Empresa':
        node_colors.append('gray') # Empresas em cinza
        node_sizes.append(1000 + G_foco.degree[node] * 100) # Tamanho pelo Grau (Hubs)
        labels[node] = node.split(' - ')[-1] # Usa apenas o nome, se o CNPJ/CPF for longo
    else: # Obra
        status = G_foco.nodes[node]['status']
        valor = G_foco.nodes[node]['valor']

        # Mapeamento de cor pelo Status (Análise de Risco)
        if status in ['Atrasada', 'Paralisada']:
            node_colors.append('red') # Risco
        elif status == 'Em Andamento':
            node_colors.append('orange')
        else: # Finalizada/Concluída
            node_colors.append('green')

        # Tamanho pelo Valor (Ponderação)
        size_scaled = valor / 10000
        node_sizes.append(max(size_scaled, 300))
        labels[node] = node # ID da Obra

# Espessura da aresta pelo Valor
edge_widths = [data['weight'] / 100000 for u, v, data in G_foco.edges(data=True)]

plt.figure(figsize=(15, 10))
plt.title('Grafo Bipartido Focado: Obras vs. Empresas (Status e Valor)', fontsize=16)

# Desenho
nx.draw_networkx_nodes(G_foco, pos, node_color=node_colors, node_size=node_sizes, alpha=0.8)
nx.draw_networkx_edges(G_foco, pos, width=edge_widths, alpha=0.5, edge_color='black')
nx.draw_networkx_labels(G_foco, pos, labels=labels, font_size=8, verticalalignment='center')

plt.axis('off')
plt.show()

# ----------------------------------------------------
# 1. CRIANDO O GRAFO DE CO-OCORRÊNCIA (Projeção)
# ----------------------------------------------------

# Vamos projetar a partir da relação Obra-Empresa.
# Duas empresas estão ligadas se trabalharam na mesma Obra (embora seja mais comum ligar por Projeto/Licitação, para demonstração usaremos Obra).

# Criar um grafo de co-ocorrência (monopartido)
G_co = nx.Graph()
empresas_unicas = df['empresa'].unique()
G_co.add_nodes_from(empresas_unicas)

# Dicionário para armazenar a frequência de co-ocorrência
co_ocorrencia = {}

# Itera sobre todas as obras
for id_obra in df['id_obra'].unique():
    # Encontra todas as empresas envolvidas na OBRA
    empresas_na_obra = df[df['id_obra'] == id_obra]['empresa'].tolist()

    # Se houver mais de uma empresa na obra (muito raro em construção, mas comum em licitações/projetos), ligue-as
    if len(empresas_na_obra) >= 2:
        # Cria todas as combinações (pares) de empresas
        from itertools import combinations
        for emp1, emp2 in combinations(empresas_na_obra, 2):
            if emp1 != emp2:
                # Ordena o par para garantir que a chave do dicionário seja única
                par = tuple(sorted((emp1, emp2)))
                co_ocorrencia[par] = co_ocorrencia.get(par, 0) + 1

# 2. Adicionar as Arestas Ponderadas ao Grafo
for (emp1, emp2), peso in co_ocorrencia.items():
    G_co.add_edge(emp1, emp2, weight=peso)

print(f"\nGrafo de Co-ocorrência criado com {G_co.number_of_nodes()} nós (apenas Empresas).")


# ----------------------------------------------------
# 3. VISUALIZAÇÃO DO GRAFO DE CO-OCORRÊNCIA
# ----------------------------------------------------

plt.figure(figsize=(12, 8))
pos_co = nx.spring_layout(G_co, k=0.5) # Spring layout funciona bem em grafos menores

# Calcula o grau dos nós para dimensionamento
degree_map = [G_co.degree(node) * 100 for node in G_co.nodes()]

# Desenha os nós (empresas)
nx.draw_networkx_nodes(G_co, pos_co, node_size=degree_map, node_color='purple', alpha=0.7)

# Desenha as arestas (espessura pelo peso da co-ocorrência)
edges = G_co.edges(data=True)
weights = [d['weight'] for u, v, d in edges]
nx.draw_networkx_edges(G_co, pos_co, width=np.array(weights) * 2, alpha=0.6, edge_color='black')

# Desenha os rótulos
labels = {node: node.split(' - ')[-1] for node in G_co.nodes()} # Limpa os rótulos
nx.draw_networkx_labels(G_co, pos_co, labels=labels, font_size=9)

plt.title("Grafo de Co-ocorrência de Empresas", fontsize=16)
plt.axis('off')
plt.show()

def limpar_valor(valor_str):
    """Remove R$, espaços, pontos (milhares) e troca vírgula por ponto (decimal)."""
    if isinstance(valor_str, str):
        valor_str = valor_str.replace('R$', '').strip()
        valor_str = valor_str.replace('.', '')
        valor_str = valor_str.replace(',', '.')
    try:
        return float(valor_str)
    except ValueError:
        return 0.0

df['valor_float'] = df['valor'].apply(limpar_valor)

# Trata Unidades Responsáveis vazias ou com apenas aspas (visto no exemplo de dados)
df['unidade_responsavel'] = df['unidade_responsavel'].str.strip().str.replace('"', '')
df['unidade_responsavel'].replace('', 'NAO_INFORMADA', inplace=True)
df['unidade_responsavel'].fillna('NAO_INFORMADA', inplace=True)

print("Limpeza de dados concluída.")

# ----------------------------------------------------
# 2.1 CRIAÇÃO DO GRAFO OBRA <--> UNIDADE RESPONSÁVEL
# ----------------------------------------------------
G_unidade = nx.Graph()

obras_nodes = df['id_obra'].unique()
unidades_nodes = df['unidade_responsavel'].unique()

# Adiciona Nós (Partição 0: Obras, Partição 1: Unidades)
for id_obra in obras_nodes:
    obra_data = df[df['id_obra'] == id_obra]
    G_unidade.add_node(id_obra,
                       bipartite=0,
                       type='Obra',
                       status=obra_data['status_obra'].iloc[0],
                       valor=obra_data['valor_float'].iloc[0])

for unidade in unidades_nodes:
    G_unidade.add_node(unidade,
                       bipartite=1,
                       type='Unidade')

# Adiciona Arestas Ponderadas (Peso = Valor da Obra)
for index, row in df.iterrows():
    if row['unidade_responsavel'] != 'NAO_INFORMADA':
        G_unidade.add_edge(row['id_obra'],
                           row['unidade_responsavel'],
                           weight=row['valor_float'])

print(f"Grafo Obra-Unidade criado com {G_unidade.number_of_nodes()} nós e {G_unidade.number_of_edges()} arestas.")

# ----------------------------------------------------
# 3.1 CÁLCULO DO GRAU PONDERADO
# ----------------------------------------------------

# Calcular o grau ponderado (soma dos pesos das arestas)
weighted_degree = G_unidade.degree(weight='weight')

# Filtrar apenas os nós que são Unidades Responsáveis
weighted_degree_unidades = {}
for node, degree in weighted_degree:
    if G_unidade.nodes[node]['type'] == 'Unidade':
        weighted_degree_unidades[node] = degree

# Converter para DataFrame para facilitar a ordenação e visualização
df_analise = pd.DataFrame(
    list(weighted_degree_unidades.items()),
    columns=['Unidade Responsável', 'Valor Total Acumulado']
)

# Ordenar por valor para identificar os hubs financeiros
df_analise = df_analise.sort_values(by='Valor Total Acumulado', ascending=False)

print("\nAnálise de Correlação (Top Unidades por Valor Acumulado):")
print(df_analise)

# VISUALIZAÇÃO DA CORRELAÇÃO - GRÁFICO DE BARRAS HORIZONTAL

plt.figure(figsize=(12,20)) # Aumentamos a altura para acomodar os rótulos horizontais

# Dados para o gráfico
valores = df_analise['Valor Total Acumulado']
unidades = df_analise['Unidade Responsável']

# Convertendo valores para milhões para rótulos mais limpos
valores_milhoes = valores / 1_000_000

# inversão (Horizontal) usando plt.barh
plt.barh(unidades, valores_milhoes, color='teal')

# Rótulos
plt.xlabel('Valor Acumulado (R$ Milhões)', fontsize=12)
plt.ylabel('Unidade Responsável', fontsize=12)
plt.title('Correlação: Valor Total de Obras por Unidade de Gestão', fontsize=16)

# Ajuste do eixo Y (posiciona os rótulos na vertical)
plt.yticks(unidades, ha='right')
plt.grid(axis='x', linestyle='--', alpha=0.7) # valor em X

# Adicionar o valor exato no final de cada barra (no eixo X)
for i, v in enumerate(valores_milhoes):
    plt.text(v + (valores_milhoes.max() * 0.01), i,
             f'{v:.2f} M', ha='left', va='center', fontsize=9)

plt.tight_layout()
plt.show()

print("\nInformações sobre as colunas:")
df.info()

# Carregar o arquivo CSV
df = pd.read_csv('obras.csv', sep=';')

# --- Tratamento de Dados Essencial ---
# Com base na análise dos metadados, as colunas 'empresa' e 'unidade_responsavel'
# têm contagens de valores não nulos diferentes do total de entradas.
# Vamos remover as linhas onde qualquer uma dessas colunas essenciais seja nula.
df_limpo = df.dropna(subset=['empresa', 'unidade_responsavel']).copy()

# manter a consistência
df_limpo['empresa'] = df_limpo['empresa'].str.strip()
df_limpo['unidade_responsavel'] = df_limpo['unidade_responsavel'].str.strip()

print(f"Número de registros válidos após a limpeza: {len(df_limpo)}")

# Criar um grafo vazio não direcionado [4]
B = nx.Graph()

# Extrair listas de nós únicos para cada conjunto
empresas = df_limpo['empresa'].unique()
unidades = df_limpo['unidade_responsavel'].unique()

# Adicionar os nós ao grafo, especificando a qual conjunto pertencem
# O atributo 'bipartite' é uma convenção do NetworkX para identificar os conjuntos
B.add_nodes_from(empresas, bipartite=0)
B.add_nodes_from(unidades, bipartite=1)

# Adicionar as arestas que conectam uma empresa a uma unidade
# Criamos uma lista de tuplas (empresa, unidade_responsavel) a partir do DataFrame
arestas = list(zip(df_limpo['empresa'], df_limpo['unidade_responsavel']))
B.add_edges_from(arestas)

print("\n--- Grafo Bipartido Criado com Sucesso! ---")

# Verificar as propriedades básicas do grafo
num_empresas = len(empresas)
num_unidades = len(unidades)

print(f"Número de nós do tipo 'Empresa' (Conjunto 0): {num_empresas}")
print(f"Número de nós do tipo 'Unidade Responsável' (Conjunto 1): {num_unidades}")
print(f"Número total de nós (vértices): {B.number_of_nodes()}")
print(f"Número total de arestas (conexões): {B.number_of_edges()}")

# Verificar se o grafo é de fato bipartido (o NetworkX tem uma função para isso)
if nx.is_bipartite(B):
    print("\nConfirmação: O grafo é bipartido.")
else:
    print("\nAlerta: O grafo não foi construído como bipartido.")

# Calcular o grau de todos os nós
graus = dict(B.degree())

# Separar os graus por tipo de nó (empresa vs. unidade) para facilitar a análise
graus_empresas = {node: grau for node, grau in graus.items() if B.nodes[node]['bipartite'] == 0}
graus_unidades = {node: grau for node, grau in graus.items() if B.nodes[node]['bipartite'] == 1}

# Ordenar para ver os mais conectados (top 5)
top_5_empresas = sorted(graus_empresas.items(), key=lambda item: item[1], reverse=True)[:5]
top_5_unidades = sorted(graus_unidades.items(), key=lambda item: item[1], reverse=True)[:5]

print("--- Análise de Centralidade de Grau ---")
print("\nTop 5 Empresas com mais conexões (unidades diferentes):")
for empresa, grau in top_5_empresas:
    print(f"- {empresa}: {grau} conexões")

print("\nTop 5 Unidades com mais conexões (empresas diferentes):")
for unidade, grau in top_5_unidades:
    print(f"- {unidade}: {grau} conexões")

# Calcular o grau médio
grau_medio = sum(graus.values()) / B.number_of_nodes()
print(f"\nGrau médio da rede: {grau_medio:.2f}")

# Calcular a densidade do grafo bipartido
# A densidade para grafos bipartidos é E / (N1 * N2)
# onde N1 e N2 são o número de nós em cada partição.
num_empresas = len(graus_empresas)
num_unidades = len(graus_unidades)
densidade_bipartida = B.number_of_edges() / (num_empresas * num_unidades)

print(f"Densidade da rede bipartida: {densidade_bipartida:.4f}")

# Pegar apenas os valores dos graus
graus_valores = list(graus.values())

# Plotar o histograma
plt.figure(figsize=(10, 6))
plt.hist(graus_valores, bins=range(1, max(graus_valores) + 1), alpha=0.75)
plt.title('Distribuição de Grau da Rede de Obras')
plt.xlabel('Grau (Número de Conexões)')
plt.ylabel('Frequência (Número de Nós)')
plt.grid(axis='y', linestyle='--')
plt.show()

# Limpeza e preparação para o Grafo Bipartido
# Conforme os metadados, precisamos das colunas 'empresa' e 'unidade_responsavel' sem nulos [3, 4]
df_bipartido = df.dropna(subset=['empresa', 'unidade_responsavel']).copy()
df_bipartido['empresa'] = df_bipartido['empresa'].str.strip()
df_bipartido['unidade_responsavel'] = df_bipartido['unidade_responsavel'].str.strip()
print(f"Registros válidos para o grafo bipartido: {len(df_bipartido)}")
print("-" * 50 + "\n")

# Bloco 2: Criação do grafo
print("--- Iteração 2: Transformando Dados em um Grafo Bipartido ---")

B = nx.Graph()

# Extrair nós únicos para cada partição
empresas = list(df_bipartido['empresa'].unique())
unidades = list(df_bipartido['unidade_responsavel'].unique())

# Adicionar nós com atributos para identificar o tipo (bipartite) e para os labels
B.add_nodes_from(empresas, bipartite=0, tipo='Empresa')
B.add_nodes_from(unidades, bipartite=1, tipo='Unidade')

# Adicionar arestas
arestas_bipartido = list(zip(df_bipartido['empresa'], df_bipartido['unidade_responsavel']))
B.add_edges_from(arestas_bipartido)

print("Grafo Bipartido (B) criado.")
print(f"  - Nós: {B.number_of_nodes()} ({len(empresas)} Empresas, {len(unidades)} Unidades)")
print(f"  - Arestas: {B.number_of_edges()}")
print("-" * 50 + "\n")

# --- VISUALIZAÇÃO DO GRAFO ---

print("Iniciando a visualização do grafo...")

# 1. Definir posições para o layout bipartido
pos = dict()
cores_nos = []
tamanhos_nos = []

# Identify the two sets of nodes based on the 'bipartite' attribute
empresas_nodes = [node for node, data in B.nodes(data=True) if data['bipartite'] == 0]
unidades_nodes = [node for node, data in B.nodes(data=True) if data['bipartite'] == 1]


# Posições para as empresas (lado esquerdo, x=0)
pos.update((node, (0, i)) for i, node in enumerate(empresas_nodes))
# Posições para as unidades (lado direito, x=1)
pos.update((node, (1, i)) for i, node in enumerate(unidades_nodes))

# 2. Definir cores e tamanhos para os nós
graus = dict(B.degree())
for node in B.nodes():
    if B.nodes[node]['bipartite'] == 0:  # Se for empresa
        cores_nos.append('skyblue')
    else:  # Se for unidade
        cores_nos.append('lightgreen')
    # O tamanho do nó será proporcional ao seu grau (multiplicado por um fator para melhor visualização)
    tamanhos_nos.append(graus[node] * 100)

# 3. Desenhar o grafo
plt.figure(figsize=(12, 18))  # Ajuste o tamanho conforme necessário
nx.draw(B,
        pos=pos,
        with_labels=True,
        node_color=cores_nos,
        node_size=tamanhos_nos,
        font_size=8,
        font_color='black',
        width=0.5,  # Espessura das arestas
        alpha=0.8)

# 4. Adicionar legendas e título
plt.title("Grafo Bipartido: Relações entre Empresas e Unidades Responsáveis", fontsize=16)
# Adicionando uma legenda manual
plt.text(-0.1, max(len(empresas_nodes), len(unidades_nodes)), 'Empresas', color='skyblue', fontweight='bold')
plt.text(1.05, max(len(empresas_nodes), len(unidades_nodes)), 'Unidades', color='lightgreen', fontweight='bold')

plt.show()

print("Visualização gerada com sucesso!")

# Bloco 3: Análise das métricas do grafo
print("--- Iteração 3: Analisando o Grafo ---")

# Calcular grau de cada nó
graus = B.degree()
nx.set_node_attributes(B, dict(graus), 'grau')

# Identificar a empresa e unidade com maior grau
graus_empresas = {n: g for n, g in graus if B.nodes[n]['bipartite'] == 0}
top_empresa = sorted(graus_empresas.items(), key=lambda x: x[1], reverse=True)[0] # Corrected index to 1 and get the top one
print(f"Empresa mais conectada: '{top_empresa[0]}' com {top_empresa[1]} conexões.") # Corrected indexing for printing

graus_unidades = {n: g for n, g in graus if B.nodes[n]['bipartite'] == 1}
top_unidade = sorted(graus_unidades.items(), key=lambda x: x[1], reverse=True)[0] # Get the top one
print(f"Unidade mais conectada: '{top_unidade[0]}' com {top_unidade[1]} conexões.") # Corrected indexing for printing


# Calcular a densidade da rede bipartida
# Need to explicitly define the partitions for bipartite density
empresas_nodes = [n for n, data in B.nodes(data=True) if data['bipartite'] == 0]
unidades_nodes = [n for n, data in B.nodes(data=True) if data['bipartite'] == 1]
densidade_b = nx.bipartite.density(B, nodes=empresas_nodes) # Pass one set of nodes

print(f"Densidade da rede bipartida: {densidade_b:.4f}")
print("-" * 50 + "\n")

# Bloco 4: Visualização interativa com Plotly
print("--- Iteração 4: Gerando Visualização Interativa com Plotly ---")

# 1. Calcular a posição dos nós usando o layout bipartido do NetworkX
pos = nx.bipartite_layout(B, empresas)

# 2. Criar o trace das arestas
edge_x = []
edge_y = []
for edge in B.edges():
    x0, y0 = pos[edge[0]] # Get the position of the first node in the edge tuple
    x1, y1 = pos[edge[1]] # Get the position of the second node in the edge tuple
    edge_x.extend([x0, x1, None])
    edge_y.extend([y0, y1, None])

edge_trace = go.Scatter(
    x=edge_x, y=edge_y,
    line=dict(width=0.5, color='#888'),
    hoverinfo='none',
    mode='lines')

# 3. Criar o trace dos nós
node_x = []
node_y = []
node_text = []
node_color = []
node_size = []

for node in B.nodes():
    x, y = pos[node]
    node_x.append(x)
    node_y.append(y)

    # Adicionar informações para o hover e estilo
    grau = B.nodes[node]['grau']
    tipo = B.nodes[node]['tipo']
    node_text.append(f"<b>{node}</b><br>Tipo: {tipo}<br>Conexões: {grau}")
    node_size.append(10 + grau * 3) # Tamanho baseado no grau
    node_color.append('skyblue' if tipo == 'Empresa' else 'lightgreen')

node_trace = go.Scatter(
    x=node_x, y=node_y,
    mode='markers',
    hoverinfo='text',
    text=node_text,
    marker=dict(
        showscale=False,
        color=node_color,
        size=node_size,
        line_width=2))

# 4. Criar a figura e exibir
fig = go.Figure(data=[edge_trace, node_trace],
             layout=go.Layout(
                title='<br>Grafo Bipartido Interativo: Relações entre Empresas e Unidades',
                titlefont_size=16,
                showlegend=False,
                hovermode='closest',
                margin=dict(b=20,l=5,r=5,t=40),
                annotations=[ dict(
                    text="Passe o mouse sobre um nó para ver os detalhes. Use o zoom para explorar.",
                    showarrow=False,
                    xref="paper", yref="paper",
                    x=0.005, y=-0.002 ) ],
                xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                yaxis=dict(showgrid=False, zeroline=False, showticklabels=False))
                )

fig.show()

print("Visualização interativa gerada! Verifique a nova janela/aba do seu navegador.")
print("-" * 50 + "\n")
print("Processo iterativo concluído!")